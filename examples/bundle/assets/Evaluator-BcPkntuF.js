import{r as rt,j as Z,n as Se,V as C,at as Kt,au as Vt,av as _i,aw as gt,d as kt,T as et,l as Ii,a as gn,ax as li,ay as mn,F as In,az as Jt,b as Ti,aA as Si,aB as Mi,aC as rn,aD as Ei,aE as Pi}from"./LegacyTriangleSplitter-CSged5Ks.js";const ui=0,Di=1,Ci=2,Tn=2,Le=1.25,Sn=1,H=32,U=H/4,fi=65535,be=Math.pow(2,-24),xn=Symbol("SKIP_GENERATION"),di={strategy:ui,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[xn]:!1};function R(i,t,e){return e.min.x=t[i],e.min.y=t[i+1],e.min.z=t[i+2],e.max.x=t[i+3],e.max.y=t[i+4],e.max.z=t[i+5],e}function Mn(i){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=i[n+3]-i[n];s>e&&(e=s,t=n)}return t}function En(i,t){t.set(i)}function Pn(i,t,e){let n,s;for(let r=0;r<3;r++){const o=r+3;n=i[r],s=t[r],e[r]=n<s?n:s,n=i[o],s=t[o],e[o]=n>s?n:s}}function Qt(i,t,e){for(let n=0;n<3;n++){const s=t[i+2*n],r=t[i+2*n+1],o=s-r,a=s+r;o<e[n]&&(e[n]=o),a>e[n+3]&&(e[n+3]=a)}}function Ot(i){const t=i[3]-i[0],e=i[4]-i[1],n=i[5]-i[2];return 2*(t*e+e*n+n*t)}function F(i,t){return t[i+15]===fi}function X(i,t){return t[i+6]}function G(i,t){return t[i+14]}function k(i){return i+U}function V(i,t){const e=t[i+6];return i+e*U}function An(i,t){return t[i+7]}function Ue(i,t,e,n,s){let r=1/0,o=1/0,a=1/0,c=-1/0,p=-1/0,l=-1/0,f=1/0,u=1/0,d=1/0,y=-1/0,g=-1/0,A=-1/0;const w=i.offset||0;for(let h=(t-w)*6,x=(t+e-w)*6;h<x;h+=6){const m=i[h+0],b=i[h+1],T=m-b,_=m+b;T<r&&(r=T),_>c&&(c=_),m<f&&(f=m),m>y&&(y=m);const B=i[h+2],M=i[h+3],I=B-M,P=B+M;I<o&&(o=I),P>p&&(p=P),B<u&&(u=B),B>g&&(g=B);const S=i[h+4],E=i[h+5],D=S-E,v=S+E;D<a&&(a=D),v>l&&(l=v),S<d&&(d=S),S>A&&(A=S)}n[0]=r,n[1]=o,n[2]=a,n[3]=c,n[4]=p,n[5]=l,s[0]=f,s[1]=u,s[2]=d,s[3]=y,s[4]=g,s[5]=A}const ct=32,vi=(i,t)=>i.candidate-t.candidate,ft=new Array(ct).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),te=new Float32Array(6);function zi(i,t,e,n,s,r){let o=-1,a=0;if(r===ui)o=Mn(t),o!==-1&&(a=(t[o]+t[o+3])/2);else if(r===Di)o=Mn(i),o!==-1&&(a=Ri(e,n,s,o));else if(r===Ci){const c=Ot(i);let p=Le*s;const l=e.offset||0,f=(n-l)*6,u=(n+s-l)*6;for(let d=0;d<3;d++){const y=t[d],w=(t[d+3]-y)/ct;if(s<ct/4){const h=[...ft];h.length=s;let x=0;for(let b=f;b<u;b+=6,x++){const T=h[x];T.candidate=e[b+2*d],T.count=0;const{bounds:_,leftCacheBounds:B,rightCacheBounds:M}=T;for(let I=0;I<3;I++)M[I]=1/0,M[I+3]=-1/0,B[I]=1/0,B[I+3]=-1/0,_[I]=1/0,_[I+3]=-1/0;Qt(b,e,_)}h.sort(vi);let m=s;for(let b=0;b<m;b++){const T=h[b];for(;b+1<m&&h[b+1].candidate===T.candidate;)h.splice(b+1,1),m--}for(let b=f;b<u;b+=6){const T=e[b+2*d];for(let _=0;_<m;_++){const B=h[_];T>=B.candidate?Qt(b,e,B.rightCacheBounds):(Qt(b,e,B.leftCacheBounds),B.count++)}}for(let b=0;b<m;b++){const T=h[b],_=T.count,B=s-T.count,M=T.leftCacheBounds,I=T.rightCacheBounds;let P=0;_!==0&&(P=Ot(M)/c);let S=0;B!==0&&(S=Ot(I)/c);const E=Sn+Le*(P*_+S*B);E<p&&(o=d,p=E,a=T.candidate)}}else{for(let m=0;m<ct;m++){const b=ft[m];b.count=0,b.candidate=y+w+m*w;const T=b.bounds;for(let _=0;_<3;_++)T[_]=1/0,T[_+3]=-1/0}for(let m=f;m<u;m+=6){let _=~~((e[m+2*d]-y)/w);_>=ct&&(_=ct-1);const B=ft[_];B.count++,Qt(m,e,B.bounds)}const h=ft[ct-1];En(h.bounds,h.rightCacheBounds);for(let m=ct-2;m>=0;m--){const b=ft[m],T=ft[m+1];Pn(b.bounds,T.rightCacheBounds,b.rightCacheBounds)}let x=0;for(let m=0;m<ct-1;m++){const b=ft[m],T=b.count,_=b.bounds,M=ft[m+1].rightCacheBounds;T!==0&&(x===0?En(_,te):Pn(_,te,te)),x+=T;let I=0,P=0;x!==0&&(I=Ot(te)/c);const S=s-x;S!==0&&(P=Ot(M)/c);const E=Sn+Le*(I*x+P*S);E<p&&(o=d,p=E,a=b.candidate)}}}}else console.warn(`BVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:a}}function Ri(i,t,e,n){let s=0;const r=i.offset;for(let o=t,a=t+e;o<a;o++)s+=i[(o-r)*6+n*2];return s/e}class Fe{constructor(){this.boundingData=new Float32Array(6)}}function Ni(i,t,e,n,s,r){let o=n,a=n+s-1;const c=r.pos,p=r.axis*2,l=e.offset||0;for(;;){for(;o<=a&&e[(o-l)*6+p]<c;)o++;for(;o<=a&&e[(a-l)*6+p]>=c;)a--;if(o<a){for(let f=0;f<t;f++){let u=i[o*t+f];i[o*t+f]=i[a*t+f],i[a*t+f]=u}for(let f=0;f<6;f++){const u=o-l,d=a-l,y=e[u*6+f];e[u*6+f]=e[d*6+f],e[d*6+f]=y}o++,a--}else return o}}let pi,Be,on,hi;const Li=Math.pow(2,32);function cn(i){return"count"in i?1:1+cn(i.left)+cn(i.right)}function Ui(i,t,e){return pi=new Float32Array(e),Be=new Uint32Array(e),on=new Uint16Array(e),hi=new Uint8Array(e),an(i,t)}function an(i,t){const e=i/4,n=i/2,s="count"in t,r=t.boundingData;for(let o=0;o<6;o++)pi[e+o]=r[o];if(s)return t.buffer?(hi.set(new Uint8Array(t.buffer),i),i+t.buffer.byteLength):(Be[e+6]=t.offset,on[n+14]=t.count,on[n+15]=fi,i+H);{const{left:o,right:a,splitAxis:c}=t,p=i+H;let l=an(p,o);const f=i/H,d=l/H-f;if(d>Li)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return Be[e+6]=d,Be[e+7]=c,an(l,a)}}function Fi(i,t,e,n,s,r){const{maxDepth:o,verbose:a,maxLeafSize:c,strategy:p,onProgress:l}=s,f=i.primitiveBuffer,u=i.primitiveBufferStride,d=new Float32Array(6);let y=!1;const g=new Fe;return Ue(t,e,n,g.boundingData,d),w(g,e,n,d),g;function A(h){l&&l((h-r.offset)/r.count)}function w(h,x,m,b=null,T=0){if(!y&&T>=o&&(y=!0,a&&console.warn(`BVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`)),m<=c||T>=o)return A(x+m),h.offset=x,h.count=m,h;const _=zi(h.boundingData,b,t,x,m,p);if(_.axis===-1)return A(x+m),h.offset=x,h.count=m,h;const B=Ni(f,u,t,x,m,_);if(B===x||B===x+m)A(x+m),h.offset=x,h.count=m;else{h.splitAxis=_.axis;const M=new Fe,I=x,P=B-x;h.left=M,Ue(t,I,P,M.boundingData,d),w(M,I,P,d,T+1);const S=new Fe,E=B,D=m-P;h.right=S,Ue(t,E,D,S.boundingData,d),w(S,E,D,d,T+1)}return h}}function ki(i,t){const e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=i.getRootRanges(t.range),s=n[0],r=n[n.length-1],o={offset:s.offset,count:r.offset+r.count-s.offset},a=new Float32Array(6*o.count);a.offset=o.offset,i.computePrimitiveBounds(o.offset,o.count,a),i._roots=n.map(c=>{const p=Fi(i,a,c.offset,c.count,t,o),l=cn(p),f=new e(H*l);return Ui(0,p,f),f})}class wn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Vi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const z=new Vi;let yt,Ut;const Et=[],ee=new wn(()=>new rt);function $i(i,t,e,n,s,r){yt=ee.getPrimitive(),Ut=ee.getPrimitive(),Et.push(yt,Ut),z.setBuffer(i._roots[t]);const o=ln(0,i.geometry,e,n,s,r);z.clearBuffer(),ee.releasePrimitive(yt),ee.releasePrimitive(Ut),Et.pop(),Et.pop();const a=Et.length;return a>0&&(Ut=Et[a-1],yt=Et[a-2]),o}function ln(i,t,e,n,s=null,r=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:p}=z;let l=i*2;if(F(l,c)){const u=X(i,p),d=G(l,c);return R(i,a,yt),n(u,d,!1,o,r+i/U,yt)}else{let I=function(S){const{uint16Array:E,uint32Array:D}=z;let v=S*2;for(;!F(v,E);)S=k(S),v=S*2;return X(S,D)},P=function(S){const{uint16Array:E,uint32Array:D}=z;let v=S*2;for(;!F(v,E);)S=V(S,D),v=S*2;return X(S,D)+G(v,E)};const u=k(i),d=V(i,p);let y=u,g=d,A,w,h,x;if(s&&(h=yt,x=Ut,R(y,a,h),R(g,a,x),A=s(h),w=s(x),w<A)){y=d,g=u;const S=A;A=w,w=S,h=x}h||(h=yt,R(y,a,h));const m=F(y*2,c),b=e(h,m,A,o+1,r+y/U);let T;if(b===Tn){const S=I(y),D=P(y)-S;T=n(S,D,!0,o+1,r+y/U,h)}else T=b&&ln(y,t,e,n,s,r,o+1);if(T)return!0;x=Ut,R(g,a,x);const _=F(g*2,c),B=e(x,_,w,o+1,r+g/U);let M;if(B===Tn){const S=I(g),D=P(g)-S;M=n(S,D,!0,o+1,r+g/U,x)}else M=B&&ln(g,t,e,n,s,r,o+1);return!!M}}const Yt=new z.constructor,Me=new z.constructor,pt=new wn(()=>new rt),Pt=new rt,Dt=new rt,ke=new rt,Ve=new rt;let $e=!1;function Oi(i,t,e,n){if($e)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");$e=!0;const s=i._roots,r=t._roots;let o,a=0,c=0;const p=new Z().copy(e).invert();for(let l=0,f=s.length;l<f;l++){Yt.setBuffer(s[l]),c=0;const u=pt.getPrimitive();R(0,Yt.float32Array,u),u.applyMatrix4(p);for(let d=0,y=r.length;d<y&&(Me.setBuffer(r[d]),o=tt(0,0,e,p,n,a,c,0,0,u),Me.clearBuffer(),c+=r[d].byteLength/H,!o);d++);if(pt.releasePrimitive(u),Yt.clearBuffer(),a+=s[l].byteLength/H,o)break}return $e=!1,o}function tt(i,t,e,n,s,r=0,o=0,a=0,c=0,p=null,l=!1){let f,u;l?(f=Me,u=Yt):(f=Yt,u=Me);const d=f.float32Array,y=f.uint32Array,g=f.uint16Array,A=u.float32Array,w=u.uint32Array,h=u.uint16Array,x=i*2,m=t*2,b=F(x,g),T=F(m,h);let _=!1;if(T&&b)l?_=s(X(t,w),G(t*2,h),X(i,y),G(i*2,g),c,o+t/U,a,r+i/U):_=s(X(i,y),G(i*2,g),X(t,w),G(t*2,h),a,r+i/U,c,o+t/U);else if(T){const B=pt.getPrimitive();R(t,A,B),B.applyMatrix4(e);const M=k(i),I=V(i,y);R(M,d,Pt),R(I,d,Dt);const P=B.intersectsBox(Pt),S=B.intersectsBox(Dt);_=P&&tt(t,M,n,e,s,o,r,c,a+1,B,!l)||S&&tt(t,I,n,e,s,o,r,c,a+1,B,!l),pt.releasePrimitive(B)}else{const B=k(t),M=V(t,w);R(B,A,ke),R(M,A,Ve);const I=p.intersectsBox(ke),P=p.intersectsBox(Ve);if(I&&P)_=tt(i,B,e,n,s,r,o,a,c+1,p,l)||tt(i,M,e,n,s,r,o,a,c+1,p,l);else if(I)if(b)_=tt(i,B,e,n,s,r,o,a,c+1,p,l);else{const S=pt.getPrimitive();S.copy(ke).applyMatrix4(e);const E=k(i),D=V(i,y);R(E,d,Pt),R(D,d,Dt);const v=S.intersectsBox(Pt),L=S.intersectsBox(Dt);_=v&&tt(B,E,n,e,s,o,r,c,a+1,S,!l)||L&&tt(B,D,n,e,s,o,r,c,a+1,S,!l),pt.releasePrimitive(S)}else if(P)if(b)_=tt(i,M,e,n,s,r,o,a,c+1,p,l);else{const S=pt.getPrimitive();S.copy(Ve).applyMatrix4(e);const E=k(i),D=V(i,y);R(E,d,Pt),R(D,d,Dt);const v=S.intersectsBox(Pt),L=S.intersectsBox(Dt);_=v&&tt(M,E,n,e,s,o,r,c,a+1,S,!l)||L&&tt(M,D,n,e,s,o,r,c,a+1,S,!l),pt.releasePrimitive(S)}}return _}const Dn=new rt,Ct=new Float32Array(6);class Hi{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(t){t={...di,...t},ki(this,t)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(t,e,n,s){let r=1/0,o=1/0,a=1/0,c=-1/0,p=-1/0,l=-1/0;for(let f=t,u=t+e;f<u;f++){this.writePrimitiveBounds(f,Ct,0);const[d,y,g,A,w,h]=Ct;d<r&&(r=d),A>c&&(c=A),y<o&&(o=y),w>p&&(p=w),g<a&&(a=g),h>l&&(l=h)}return n[s+0]=r,n[s+1]=o,n[s+2]=a,n[s+3]=c,n[s+4]=p,n[s+5]=l,n}computePrimitiveBounds(t,e,n){const s=n.offset||0;for(let r=t,o=t+e;r<o;r++){this.writePrimitiveBounds(r,Ct,0);const[a,c,p,l,f,u]=Ct,d=(a+l)/2,y=(c+f)/2,g=(p+u)/2,A=(l-a)/2,w=(f-c)/2,h=(u-p)/2,x=(r-s)*6;n[x+0]=d,n[x+1]=A+(Math.abs(d)+A)*be,n[x+2]=y,n[x+3]=w+(Math.abs(y)+w)*be,n[x+4]=g,n[x+5]=h+(Math.abs(g)+h)*be}return n}shiftPrimitiveOffsets(t){const e=this._indirectBuffer;if(e)for(let n=0,s=e.length;n<s;n++)e[n]+=t;else{const n=this._roots;for(let s=0;s<n.length;s++){const r=n[s],o=new Uint32Array(r),a=new Uint16Array(r),c=r.byteLength/H;for(let p=0;p<c;p++){const l=U*p,f=2*l;F(f,a)&&(o[l+6]+=t)}}}}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),r=new Uint16Array(n);o(0);function o(a,c=0){const p=a*2,l=F(p,r);if(l){const f=s[a+6],u=r[p+14];t(c,l,new Float32Array(n,a*4,6),f,u)}else{const f=k(a),u=V(a,s),d=An(a,s);t(c,l,new Float32Array(n,a*4,6),d)||(o(f,c+1),o(u,c+1))}}}refit(){const t=this._roots;for(let e=0,n=t.length;e<n;e++){const s=t[e],r=new Uint32Array(s),o=new Uint16Array(s),a=new Float32Array(s),c=s.byteLength/H;for(let p=c-1;p>=0;p--){const l=p*U,f=l*2;if(F(f,o)){const d=X(l,r),y=G(f,o);this.writePrimitiveRangeBounds(d,y,Ct,0),a.set(Ct,l)}else{const d=k(l),y=V(l,r);for(let g=0;g<3;g++){const A=a[d+g],w=a[d+g+3],h=a[y+g],x=a[y+g+3];a[l+g]=A<h?A:h,a[l+g+3]=w>x?w:x}}}}}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{R(0,new Float32Array(n),Dn),t.union(Dn)}),t}shapecast(t){let{boundsTraverseOrder:e,intersectsBounds:n,intersectsRange:s,intersectsPrimitive:r,scratchPrimitive:o,iterate:a}=t;if(s&&r){const f=s;s=(u,d,y,g,A)=>f(u,d,y,g,A)?!0:a(u,d,this,r,y,g,o)}else s||(r?s=(f,u,d,y)=>a(f,u,this,r,d,y,o):s=(f,u,d)=>d);let c=!1,p=0;const l=this._roots;for(let f=0,u=l.length;f<u;f++){const d=l[f];if(c=$i(this,f,n,s,e,p),c)break;p+=d.byteLength/H}return c}bvhcast(t,e,n){let{intersectsRanges:s}=n;return Oi(this,t,e,s)}}function Xi(){return typeof SharedArrayBuffer<"u"}function bn(i){return i.index?i.index.count:i.attributes.position.count}function De(i){return bn(i)/3}function Gi(i,t=ArrayBuffer){return i>65535?new Uint32Array(new t(4*i)):new Uint16Array(new t(2*i))}function Wi(i,t){if(!i.index){const e=i.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Gi(e,n);i.setIndex(new Se(s,1));for(let r=0;r<e;r++)s[r]=r}}function ji(i,t,e){const n=bn(i)/e,s=t||i.drawRange,r=s.start/e,o=(s.start+s.count)/e,a=Math.max(0,r),c=Math.min(n,o)-a;return{offset:Math.floor(a),count:Math.floor(c)}}function qi(i,t){return i.groups.map(e=>({offset:e.start/t,count:e.count/t}))}function Cn(i,t,e){const n=ji(i,t,e),s=qi(i,e);if(!s.length)return[n];const r=[],o=n.offset,a=n.offset+n.count,c=bn(i)/e,p=[];for(const u of s){const{offset:d,count:y}=u,g=d,A=isFinite(y)?y:c-d,w=d+A;g<a&&w>o&&(p.push({pos:Math.max(o,g),isStart:!0}),p.push({pos:Math.min(a,w),isStart:!1}))}p.sort((u,d)=>u.pos!==d.pos?u.pos-d.pos:u.type==="end"?-1:1);let l=0,f=null;for(const u of p){const d=u.pos;l!==0&&d!==f&&r.push({offset:f,count:d-f}),l+=u.isStart?1:-1,f=d}return r}function Yi(i,t){const e=i[i.length-1],n=e.offset+e.count>2**16,s=i.reduce((p,l)=>p+l.count,0),r=n?4:2,o=t?new SharedArrayBuffer(s*r):new ArrayBuffer(s*r),a=n?new Uint32Array(o):new Uint16Array(o);let c=0;for(let p=0;p<i.length;p++){const{offset:l,count:f}=i[p];for(let u=0;u<f;u++)a[c+u]=l+u;c+=f}return a}class Zi extends Hi{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(t){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(t){}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(e.useSharedArrayBuffer&&!Xi())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=t,this.resolvePrimitiveIndex=e.indirect?n=>this._indirectBuffer[n]:n=>n,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,e={...di,...e},e[xn]||this.init(e)}init(t){const{geometry:e,primitiveStride:n}=this;if(t.indirect){const s=Cn(e,t.range,n),r=Yi(s,t.useSharedArrayBuffer);this._indirectBuffer=r}else Wi(e,t);super.init(t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new rt))}getRootRanges(t){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:Cn(this.geometry,t,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class W{constructor(t,e,n){this.isOrientedBox=!0,this.min=new C,this.max=new C,this.matrix=new Z,this.invMatrix=new Z,this.points=new Array(8).fill().map(()=>new C),this.satAxes=new Array(3).fill().map(()=>new C),this.satBounds=new Array(3).fill().map(()=>new Kt),this.alignedSatBounds=new Array(3).fill().map(()=>new Kt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}W.prototype.update=(function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let p=0;p<=1;p++)for(let l=0;l<=1;l++)for(let f=0;f<=1;f++){const u=1*p|2*l|4*f,d=s[u];d.x=p?n.x:e.x,d.y=l?n.y:e.y,d.z=f?n.z:e.z,d.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,a=s[0];for(let p=0;p<3;p++){const l=o[p],f=r[p],u=1<<p,d=s[u];l.subVectors(a,d),f.setFromPoints(l,s)}const c=this.alignedSatBounds;c[0].setFromPointsField(s,"x"),c[1].setFromPointsField(s,"y"),c[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();W.prototype.intersectsBox=(function(){const i=new Kt;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,r=this.satBounds,o=this.satAxes,a=this.alignedSatBounds;if(i.min=n.x,i.max=s.x,a[0].isSeparated(i)||(i.min=n.y,i.max=s.y,a[1].isSeparated(i))||(i.min=n.z,i.max=s.z,a[2].isSeparated(i)))return!1;for(let c=0;c<3;c++){const p=o[c],l=r[c];if(i.setFromBox(p,e),l.isSeparated(i))return!1}return!0}})();W.prototype.intersectsTriangle=(function(){const i=new Vt,t=new Array(3),e=new Kt,n=new Kt,s=new C;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(i.copy(o),i.update(),o=i);const a=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let u=0;u<3;u++){const d=a[u],y=c[u];if(e.setFromPoints(y,t),d.isSeparated(e))return!1}const p=o.satBounds,l=o.satAxes,f=this.points;for(let u=0;u<3;u++){const d=p[u],y=l[u];if(e.setFromPoints(y,f),d.isSeparated(e))return!1}for(let u=0;u<3;u++){const d=c[u];for(let y=0;y<4;y++){const g=l[y];if(s.crossVectors(d,g),e.setFromPoints(s,t),n.setFromPoints(s,f),e.isSeparated(n))return!1}}return!0}})();W.prototype.closestPointToPoint=(function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}})();W.prototype.distanceToPoint=(function(){const i=new C;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}})();W.prototype.distanceToBox=(function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new gt),e=new Array(12).fill().map(()=>new gt),n=new C,s=new C;return function(o,a=0,c=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||p)&&(o.getCenter(s),this.closestPointToPoint(s,n),o.closestPointToPoint(n,s),c&&c.copy(n),p&&p.copy(s)),0;const l=a*a,f=o.min,u=o.max,d=this.points;let y=1/0;for(let A=0;A<8;A++){const w=d[A];s.copy(w).clamp(f,u);const h=w.distanceToSquared(s);if(h<y&&(y=h,c&&c.copy(w),p&&p.copy(s),h<l))return Math.sqrt(h)}let g=0;for(let A=0;A<3;A++)for(let w=0;w<=1;w++)for(let h=0;h<=1;h++){const x=(A+1)%3,m=(A+2)%3,b=w<<x|h<<m,T=1<<A|w<<x|h<<m,_=d[b],B=d[T];t[g].set(_,B);const I=i[A],P=i[x],S=i[m],E=e[g],D=E.start,v=E.end;D[I]=f[I],D[P]=w?f[P]:u[P],D[S]=h?f[S]:u[P],v[I]=u[I],v[P]=w?f[P]:u[P],v[S]=h?f[S]:u[P],g++}for(let A=0;A<=1;A++)for(let w=0;w<=1;w++)for(let h=0;h<=1;h++){s.x=A?u.x:f.x,s.y=w?u.y:f.y,s.z=h?u.z:f.z,this.closestPointToPoint(s,n);const x=s.distanceToSquared(n);if(x<y&&(y=x,c&&c.copy(n),p&&p.copy(s),x<l))return Math.sqrt(x)}for(let A=0;A<12;A++){const w=t[A];for(let h=0;h<12;h++){const x=e[h];_i(w,x,n,s);const m=n.distanceToSquared(s);if(m<y&&(y=m,c&&c.copy(n),p&&p.copy(s),m<l))return Math.sqrt(m)}}return Math.sqrt(y)}})();class Ki extends wn{constructor(){super(()=>new Vt)}}const K=new Ki,Ht=new C,Oe=new C;function Ji(i,t,e={},n=0,s=1/0){const r=n*n,o=s*s;let a=1/0,c=null;if(i.shapecast({boundsTraverseOrder:l=>(Ht.copy(t).clamp(l.min,l.max),Ht.distanceToSquared(t)),intersectsBounds:(l,f,u)=>u<a&&u<o,intersectsTriangle:(l,f)=>{l.closestPointToPoint(t,Ht);const u=t.distanceToSquared(Ht);return u<a&&(Oe.copy(Ht),a=u,c=f),u<r}}),a===1/0)return null;const p=Math.sqrt(a);return e.point?e.point.copy(Oe):e.point=Oe.clone(),e.distance=p,e.faceIndex=c,e}const ne=parseInt(li)>=169,Qi=parseInt(li)<=161,xt=new C,At=new C,wt=new C,ie=new kt,se=new kt,re=new kt,vn=new C,zn=new C,Rn=new C,Xt=new C;function ts(i,t,e,n,s,r,o,a){let c;if(r===Ii?c=i.intersectTriangle(n,e,t,!0,s):c=i.intersectTriangle(t,e,n,r!==gn,s),c===null)return null;const p=i.origin.distanceTo(s);return p<o||p>a?null:{distance:p,point:s.clone()}}function Nn(i,t,e,n,s,r,o,a,c,p,l){xt.fromBufferAttribute(t,r),At.fromBufferAttribute(t,o),wt.fromBufferAttribute(t,a);const f=ts(i,xt,At,wt,Xt,c,p,l);if(f){if(n){ie.fromBufferAttribute(n,r),se.fromBufferAttribute(n,o),re.fromBufferAttribute(n,a),f.uv=new kt;const d=et.getInterpolation(Xt,xt,At,wt,ie,se,re,f.uv);ne||(f.uv=d)}if(s){ie.fromBufferAttribute(s,r),se.fromBufferAttribute(s,o),re.fromBufferAttribute(s,a),f.uv1=new kt;const d=et.getInterpolation(Xt,xt,At,wt,ie,se,re,f.uv1);ne||(f.uv1=d),Qi&&(f.uv2=f.uv1)}if(e){vn.fromBufferAttribute(e,r),zn.fromBufferAttribute(e,o),Rn.fromBufferAttribute(e,a),f.normal=new C;const d=et.getInterpolation(Xt,xt,At,wt,vn,zn,Rn,f.normal);f.normal.dot(i.direction)>0&&f.normal.multiplyScalar(-1),ne||(f.normal=d)}const u={a:r,b:o,c:a,normal:new C,materialIndex:0};if(et.getNormal(xt,At,wt,u.normal),f.face=u,f.faceIndex=r,ne){const d=new C;et.getBarycoord(Xt,xt,At,wt,d),f.barycoord=d}}return f}function Ln(i){return i&&i.isMaterial?i.side:i}function Ce(i,t,e,n,s,r,o){const a=n*3;let c=a+0,p=a+1,l=a+2;const{index:f,groups:u}=i;i.index&&(c=f.getX(c),p=f.getX(p),l=f.getX(l));const{position:d,normal:y,uv:g,uv1:A}=i.attributes;if(Array.isArray(t)){const w=n*3;for(let h=0,x=u.length;h<x;h++){const{start:m,count:b,materialIndex:T}=u[h];if(w>=m&&w<m+b){const _=Ln(t[T]),B=Nn(e,d,y,g,A,c,p,l,_,r,o);if(B)if(B.faceIndex=n,B.face.materialIndex=T,s)s.push(B);else return B}}}else{const w=Ln(t),h=Nn(e,d,y,g,A,c,p,l,w,r,o);if(h)if(h.faceIndex=n,h.face.materialIndex=0,s)s.push(h);else return h}return null}function N(i,t,e,n){const s=i.a,r=i.b,o=i.c;let a=t,c=t+1,p=t+2;e&&(a=e.getX(a),c=e.getX(c),p=e.getX(p)),s.x=n.getX(a),s.y=n.getY(a),s.z=n.getZ(a),r.x=n.getX(c),r.y=n.getY(c),r.z=n.getZ(c),o.x=n.getX(p),o.y=n.getY(p),o.z=n.getZ(p)}function es(i,t,e,n,s,r,o,a){const{geometry:c,_indirectBuffer:p}=i;for(let l=n,f=n+s;l<f;l++)Ce(c,t,e,l,r,o,a)}function ns(i,t,e,n,s,r,o){const{geometry:a,_indirectBuffer:c}=i;let p=1/0,l=null;for(let f=n,u=n+s;f<u;f++){let d;d=Ce(a,t,e,f,null,r,o),d&&d.distance<p&&(l=d,p=d.distance)}return l}function is(i,t,e,n,s,r,o){const{geometry:a}=e,{index:c}=a,p=a.attributes.position;for(let l=i,f=t+i;l<f;l++){let u;if(u=l,N(o,u*3,c,p),o.needsUpdate=!0,n(o,u,s,r))return!0}return!1}function ss(i,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=i.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let r,o,a,c,p=0;const l=i._roots;for(let u=0,d=l.length;u<d;u++)r=l[u],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),f(0,p),p+=r.byteLength;function f(u,d,y=!1){const g=u*2;if(F(g,a)){const A=X(u,o),w=G(g,a);let h=1/0,x=1/0,m=1/0,b=-1/0,T=-1/0,_=-1/0;for(let B=3*A,M=3*(A+w);B<M;B++){let I=n[B];const P=s.getX(I),S=s.getY(I),E=s.getZ(I);P<h&&(h=P),P>b&&(b=P),S<x&&(x=S),S>T&&(T=S),E<m&&(m=E),E>_&&(_=E)}return c[u+0]!==h||c[u+1]!==x||c[u+2]!==m||c[u+3]!==b||c[u+4]!==T||c[u+5]!==_?(c[u+0]=h,c[u+1]=x,c[u+2]=m,c[u+3]=b,c[u+4]=T,c[u+5]=_,!0):!1}else{const A=k(u),w=V(u,o);let h=y,x=!1,m=!1;if(t){if(!h){const I=A/U+d/H,P=w/U+d/H;x=t.has(I),m=t.has(P),h=!x&&!m}}else x=!0,m=!0;const b=h||x,T=h||m;let _=!1;b&&(_=f(A,d,h));let B=!1;T&&(B=f(w,d,h));const M=_||B;if(M)for(let I=0;I<3;I++){const P=A+I,S=w+I,E=c[P],D=c[P+3],v=c[S],L=c[S+3];c[u+I]=E<v?E:v,c[u+I+3]=D>L?D:L}return M}}}function mt(i,t,e,n,s){let r,o,a,c,p,l;const f=1/e.direction.x,u=1/e.direction.y,d=1/e.direction.z,y=e.origin.x,g=e.origin.y,A=e.origin.z;let w=t[i],h=t[i+3],x=t[i+1],m=t[i+3+1],b=t[i+2],T=t[i+3+2];return f>=0?(r=(w-y)*f,o=(h-y)*f):(r=(h-y)*f,o=(w-y)*f),u>=0?(a=(x-g)*u,c=(m-g)*u):(a=(m-g)*u,c=(x-g)*u),r>c||a>o||((a>r||isNaN(r))&&(r=a),(c<o||isNaN(o))&&(o=c),d>=0?(p=(b-A)*d,l=(T-A)*d):(p=(T-A)*d,l=(b-A)*d),r>l||p>o)?!1:((p>r||r!==r)&&(r=p),(l<o||o!==o)&&(o=l),r<=s&&o>=n)}function rs(i,t,e,n,s,r,o,a){const{geometry:c,_indirectBuffer:p}=i;for(let l=n,f=n+s;l<f;l++){let u=p?p[l]:l;Ce(c,t,e,u,r,o,a)}}function os(i,t,e,n,s,r,o){const{geometry:a,_indirectBuffer:c}=i;let p=1/0,l=null;for(let f=n,u=n+s;f<u;f++){let d;d=Ce(a,t,e,c?c[f]:f,null,r,o),d&&d.distance<p&&(l=d,p=d.distance)}return l}function cs(i,t,e,n,s,r,o){const{geometry:a}=e,{index:c}=a,p=a.attributes.position;for(let l=i,f=t+i;l<f;l++){let u;if(u=e.resolveTriangleIndex(l),N(o,u*3,c,p),o.needsUpdate=!0,n(o,u,s,r))return!0}return!1}function as(i,t,e,n,s,r,o){z.setBuffer(i._roots[t]),un(0,i,e,n,s,r,o),z.clearBuffer()}function un(i,t,e,n,s,r,o){const{float32Array:a,uint16Array:c,uint32Array:p}=z,l=i*2;if(F(l,c)){const u=X(i,p),d=G(l,c);es(t,e,n,u,d,s,r,o)}else{const u=k(i);mt(u,a,n,r,o)&&un(u,t,e,n,s,r,o);const d=V(i,p);mt(d,a,n,r,o)&&un(d,t,e,n,s,r,o)}}const ls=["x","y","z"];function us(i,t,e,n,s,r){z.setBuffer(i._roots[t]);const o=fn(0,i,e,n,s,r);return z.clearBuffer(),o}function fn(i,t,e,n,s,r){const{float32Array:o,uint16Array:a,uint32Array:c}=z;let p=i*2;if(F(p,a)){const f=X(i,c),u=G(p,a);return ns(t,e,n,f,u,s,r)}else{const f=An(i,c),u=ls[f],y=n.direction[u]>=0;let g,A;y?(g=k(i),A=V(i,c)):(g=V(i,c),A=k(i));const h=mt(g,o,n,s,r)?fn(g,t,e,n,s,r):null;if(h){const b=h.point[u];if(y?b<=o[A+f]:b>=o[A+f+3])return h}const m=mt(A,o,n,s,r)?fn(A,t,e,n,s,r):null;return h&&m?h.distance<=m.distance?h:m:h||m||null}}const oe=new rt,vt=new Vt,zt=new Vt,Gt=new Z,Un=new W,ce=new W;function fs(i,t,e,n){z.setBuffer(i._roots[t]);const s=dn(0,i,e,n);return z.clearBuffer(),s}function dn(i,t,e,n,s=null){const{float32Array:r,uint16Array:o,uint32Array:a}=z;let c=i*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Un.set(e.boundingBox.min,e.boundingBox.max,n),s=Un),F(c,o)){const l=t.geometry,f=l.index,u=l.attributes.position,d=e.index,y=e.attributes.position,g=X(i,a),A=G(c,o);if(Gt.copy(n).invert(),e.boundsTree)return R(i,r,ce),ce.matrix.copy(Gt),ce.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:h=>ce.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let x=g*3,m=(A+g)*3;x<m;x+=3)if(N(zt,x,f,u),zt.needsUpdate=!0,h.intersectsTriangle(zt))return!0;return!1}});{const w=De(e);for(let h=g*3,x=(A+g)*3;h<x;h+=3){N(vt,h,f,u),vt.a.applyMatrix4(Gt),vt.b.applyMatrix4(Gt),vt.c.applyMatrix4(Gt),vt.needsUpdate=!0;for(let m=0,b=w*3;m<b;m+=3)if(N(zt,m,d,y),zt.needsUpdate=!0,vt.intersectsTriangle(zt))return!0}}}else{const l=k(i),f=V(i,a);return R(l,r,oe),!!(s.intersectsBox(oe)&&dn(l,t,e,n,s)||(R(f,r,oe),s.intersectsBox(oe)&&dn(f,t,e,n,s)))}}const ae=new Z,He=new W,Wt=new W,ds=new C,ps=new C,hs=new C,ys=new C;function gs(i,t,e,n={},s={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),He.set(t.boundingBox.min,t.boundingBox.max,e),He.needsUpdate=!0;const a=i.geometry,c=a.attributes.position,p=a.index,l=t.attributes.position,f=t.index,u=K.getPrimitive(),d=K.getPrimitive();let y=ds,g=ps,A=null,w=null;s&&(A=hs,w=ys);let h=1/0,x=null,m=null;return ae.copy(e).invert(),Wt.matrix.copy(ae),i.shapecast({boundsTraverseOrder:b=>He.distanceToBox(b),intersectsBounds:(b,T,_)=>_<h&&_<o?(T&&(Wt.min.copy(b.min),Wt.max.copy(b.max),Wt.needsUpdate=!0),!0):!1,intersectsRange:(b,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>Wt.distanceToBox(B),intersectsBounds:(B,M,I)=>I<h&&I<o,intersectsRange:(B,M)=>{for(let I=B,P=B+M;I<P;I++){N(d,3*I,f,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let S=b,E=b+T;S<E;S++){N(u,3*S,p,c),u.needsUpdate=!0;const D=u.distanceToTriangle(d,y,A);if(D<h&&(g.copy(y),w&&w.copy(A),h=D,x=S,m=I),D<r)return!0}}}});{const _=De(t);for(let B=0,M=_;B<M;B++){N(d,3*B,f,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let I=b,P=b+T;I<P;I++){N(u,3*I,p,c),u.needsUpdate=!0;const S=u.distanceToTriangle(d,y,A);if(S<h&&(g.copy(y),w&&w.copy(A),h=S,x=I,m=B),S<r)return!0}}}}}),K.releasePrimitive(u),K.releasePrimitive(d),h===1/0?null:(n.point?n.point.copy(g):n.point=g.clone(),n.distance=h,n.faceIndex=x,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(ae),g.applyMatrix4(ae),s.distance=g.sub(s.point).length(),s.faceIndex=m),n)}function ms(i,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=i.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let r,o,a,c,p=0;const l=i._roots;for(let u=0,d=l.length;u<d;u++)r=l[u],o=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),f(0,p),p+=r.byteLength;function f(u,d,y=!1){const g=u*2;if(F(g,a)){const A=X(u,o),w=G(g,a);let h=1/0,x=1/0,m=1/0,b=-1/0,T=-1/0,_=-1/0;for(let B=A,M=A+w;B<M;B++){const I=3*i.resolveTriangleIndex(B);for(let P=0;P<3;P++){let S=I+P;S=n?n[S]:S;const E=s.getX(S),D=s.getY(S),v=s.getZ(S);E<h&&(h=E),E>b&&(b=E),D<x&&(x=D),D>T&&(T=D),v<m&&(m=v),v>_&&(_=v)}}return c[u+0]!==h||c[u+1]!==x||c[u+2]!==m||c[u+3]!==b||c[u+4]!==T||c[u+5]!==_?(c[u+0]=h,c[u+1]=x,c[u+2]=m,c[u+3]=b,c[u+4]=T,c[u+5]=_,!0):!1}else{const A=k(u),w=V(u,o);let h=y,x=!1,m=!1;if(t){if(!h){const I=A/U+d/H,P=w/U+d/H;x=t.has(I),m=t.has(P),h=!x&&!m}}else x=!0,m=!0;const b=h||x,T=h||m;let _=!1;b&&(_=f(A,d,h));let B=!1;T&&(B=f(w,d,h));const M=_||B;if(M)for(let I=0;I<3;I++){const P=A+I,S=w+I,E=c[P],D=c[P+3],v=c[S],L=c[S+3];c[u+I]=E<v?E:v,c[u+I+3]=D>L?D:L}return M}}}function xs(i,t,e,n,s,r,o){z.setBuffer(i._roots[t]),pn(0,i,e,n,s,r,o),z.clearBuffer()}function pn(i,t,e,n,s,r,o){const{float32Array:a,uint16Array:c,uint32Array:p}=z,l=i*2;if(F(l,c)){const u=X(i,p),d=G(l,c);rs(t,e,n,u,d,s,r,o)}else{const u=k(i);mt(u,a,n,r,o)&&pn(u,t,e,n,s,r,o);const d=V(i,p);mt(d,a,n,r,o)&&pn(d,t,e,n,s,r,o)}}const As=["x","y","z"];function ws(i,t,e,n,s,r){z.setBuffer(i._roots[t]);const o=hn(0,i,e,n,s,r);return z.clearBuffer(),o}function hn(i,t,e,n,s,r){const{float32Array:o,uint16Array:a,uint32Array:c}=z;let p=i*2;if(F(p,a)){const f=X(i,c),u=G(p,a);return os(t,e,n,f,u,s,r)}else{const f=An(i,c),u=As[f],y=n.direction[u]>=0;let g,A;y?(g=k(i),A=V(i,c)):(g=V(i,c),A=k(i));const h=mt(g,o,n,s,r)?hn(g,t,e,n,s,r):null;if(h){const b=h.point[u];if(y?b<=o[A+f]:b>=o[A+f+3])return h}const m=mt(A,o,n,s,r)?hn(A,t,e,n,s,r):null;return h&&m?h.distance<=m.distance?h:m:h||m||null}}const le=new rt,Rt=new Vt,Nt=new Vt,jt=new Z,Fn=new W,ue=new W;function bs(i,t,e,n){z.setBuffer(i._roots[t]);const s=yn(0,i,e,n);return z.clearBuffer(),s}function yn(i,t,e,n,s=null){const{float32Array:r,uint16Array:o,uint32Array:a}=z;let c=i*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Fn.set(e.boundingBox.min,e.boundingBox.max,n),s=Fn),F(c,o)){const l=t.geometry,f=l.index,u=l.attributes.position,d=e.index,y=e.attributes.position,g=X(i,a),A=G(c,o);if(jt.copy(n).invert(),e.boundsTree)return R(i,r,ue),ue.matrix.copy(jt),ue.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:h=>ue.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let x=g,m=A+g;x<m;x++)if(N(Nt,3*t.resolveTriangleIndex(x),f,u),Nt.needsUpdate=!0,h.intersectsTriangle(Nt))return!0;return!1}});{const w=De(e);for(let h=g,x=A+g;h<x;h++){const m=t.resolveTriangleIndex(h);N(Rt,3*m,f,u),Rt.a.applyMatrix4(jt),Rt.b.applyMatrix4(jt),Rt.c.applyMatrix4(jt),Rt.needsUpdate=!0;for(let b=0,T=w*3;b<T;b+=3)if(N(Nt,b,d,y),Nt.needsUpdate=!0,Rt.intersectsTriangle(Nt))return!0}}}else{const l=k(i),f=V(i,a);return R(l,r,le),!!(s.intersectsBox(le)&&yn(l,t,e,n,s)||(R(f,r,le),s.intersectsBox(le)&&yn(f,t,e,n,s)))}}const fe=new Z,Xe=new W,qt=new W,Bs=new C,_s=new C,Is=new C,Ts=new C;function Ss(i,t,e,n={},s={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Xe.set(t.boundingBox.min,t.boundingBox.max,e),Xe.needsUpdate=!0;const a=i.geometry,c=a.attributes.position,p=a.index,l=t.attributes.position,f=t.index,u=K.getPrimitive(),d=K.getPrimitive();let y=Bs,g=_s,A=null,w=null;s&&(A=Is,w=Ts);let h=1/0,x=null,m=null;return fe.copy(e).invert(),qt.matrix.copy(fe),i.shapecast({boundsTraverseOrder:b=>Xe.distanceToBox(b),intersectsBounds:(b,T,_)=>_<h&&_<o?(T&&(qt.min.copy(b.min),qt.max.copy(b.max),qt.needsUpdate=!0),!0):!1,intersectsRange:(b,T)=>{if(t.boundsTree){const _=t.boundsTree;return _.shapecast({boundsTraverseOrder:B=>qt.distanceToBox(B),intersectsBounds:(B,M,I)=>I<h&&I<o,intersectsRange:(B,M)=>{for(let I=B,P=B+M;I<P;I++){const S=_.resolveTriangleIndex(I);N(d,3*S,f,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let E=b,D=b+T;E<D;E++){const v=i.resolveTriangleIndex(E);N(u,3*v,p,c),u.needsUpdate=!0;const L=u.distanceToTriangle(d,y,A);if(L<h&&(g.copy(y),w&&w.copy(A),h=L,x=E,m=I),L<r)return!0}}}})}else{const _=De(t);for(let B=0,M=_;B<M;B++){N(d,3*B,f,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let I=b,P=b+T;I<P;I++){const S=i.resolveTriangleIndex(I);N(u,3*S,p,c),u.needsUpdate=!0;const E=u.distanceToTriangle(d,y,A);if(E<h&&(g.copy(y),w&&w.copy(A),h=E,x=I,m=B),E<r)return!0}}}}}),K.releasePrimitive(u),K.releasePrimitive(d),h===1/0?null:(n.point?n.point.copy(g):n.point=g.clone(),n.distance=h,n.faceIndex=x,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(fe),g.applyMatrix4(fe),s.distance=g.sub(s.point).length(),s.faceIndex=m),n)}function kn(i,t,e){return i===null?null:(i.point.applyMatrix4(t.matrixWorld),i.distance=i.point.distanceTo(e.ray.origin),i.object=t,i)}const de=new W,pe=new mn,Vn=new C,$n=new Z,On=new C,Ge=["getX","getY","getZ"];class Ee extends Zi{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,r=t._indirectBuffer,o=n.getIndex(),a={version:1,roots:null,index:null,indirectBuffer:null};return e.cloneBuffers?(a.roots=s.map(c=>c.slice()),a.index=o?o.array.slice():null,a.indirectBuffer=r?r.slice():null):(a.roots=s,a.index=o?o.array:null,a.indirectBuffer=r),a}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:s,roots:r,indirectBuffer:o}=t;t.version||(console.warn("MeshBVH.deserialize: Serialization format has been changed and will be fixed up. It is recommended to regenerate any stored serialized data."),c(r));const a=new Ee(e,{...n,[xn]:!0});if(a._roots=r,a._indirectBuffer=o||null,n.setIndex){const p=e.getIndex();if(p===null){const l=new Se(t.index,1,!1);e.setIndex(l)}else p.array!==s&&(p.array.set(s),p.needsUpdate=!0)}return a;function c(p){for(let l=0;l<p.length;l++){const f=p[l],u=new Uint32Array(f),d=new Uint16Array(f);for(let y=0,g=f.byteLength/H;y<g;y++){const A=U*y,w=2*A;F(w,d)||(u[A+6]=u[A+6]/U-y)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(t,e={}){e.maxLeafTris&&(console.warn('MeshBVH: "maxLeafTris" option has been deprecated. Use maxLeafSize, instead.'),e={...e,maxLeafSize:e.maxLeafTris}),super(t,e)}shiftTriangleOffsets(t){return super.shiftPrimitiveOffsets(t)}writePrimitiveBounds(t,e,n){const s=this.geometry,r=this._indirectBuffer,o=s.attributes.position,a=s.index?s.index.array:null,p=(r?r[t]:t)*3;let l=p+0,f=p+1,u=p+2;a&&(l=a[l],f=a[f],u=a[u]);for(let d=0;d<3;d++){const y=o[Ge[d]](l),g=o[Ge[d]](f),A=o[Ge[d]](u);let w=y;g<w&&(w=g),A<w&&(w=A);let h=y;g>h&&(h=g),A>h&&(h=A),e[n+d]=w,e[n+d+3]=h}return e}computePrimitiveBounds(t,e,n){const s=this.geometry,r=this._indirectBuffer,o=s.attributes.position,a=s.index?s.index.array:null,c=o.normalized;if(t<0||e+t-n.offset>n.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const p=o.array,l=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const u=["getX","getY","getZ"],d=n.offset;for(let y=t,g=t+e;y<g;y++){const w=(r?r[y]:y)*3,h=(y-d)*6;let x=w+0,m=w+1,b=w+2;a&&(x=a[x],m=a[m],b=a[b]),c||(x=x*f+l,m=m*f+l,b=b*f+l);for(let T=0;T<3;T++){let _,B,M;c?(_=o[u[T]](x),B=o[u[T]](m),M=o[u[T]](b)):(_=p[x+T],B=p[m+T],M=p[b+T]);let I=_;B<I&&(I=B),M<I&&(I=M);let P=_;B>P&&(P=B),M>P&&(P=M);const S=(P-I)/2,E=T*2;n[h+E+0]=I+S,n[h+E+1]=S+(Math.abs(I)+S)*be}}return n}raycastObject3D(t,e,n=[]){const{material:s}=t;if(s===void 0)return;$n.copy(t.matrixWorld).invert(),pe.copy(e.ray).applyMatrix4($n),On.setFromMatrixScale(t.matrixWorld),Vn.copy(pe.direction).multiply(On);const r=Vn.length(),o=e.near/r,a=e.far/r;if(e.firstHitOnly===!0){let c=this.raycastFirst(pe,s,o,a);c=kn(c,t,e),c&&n.push(c)}else{const c=this.raycast(pe,s,o,a);for(let p=0,l=c.length;p<l;p++){const f=kn(c[p],t,e);f&&n.push(f)}}return n}refit(t=null){return(this.indirect?ms:ss)(this,t)}raycast(t,e=In,n=0,s=1/0){const r=this._roots,o=[],a=this.indirect?xs:as;for(let c=0,p=r.length;c<p;c++)a(this,c,e,t,o,n,s);return o}raycastFirst(t,e=In,n=0,s=1/0){const r=this._roots;let o=null;const a=this.indirect?ws:us;for(let c=0,p=r.length;c<p;c++){const l=a(this,c,e,t,n,s);l!=null&&(o==null||l.distance<o.distance)&&(o=l)}return o}intersectsGeometry(t,e){let n=!1;const s=this._roots,r=this.indirect?bs:fs;for(let o=0,a=s.length;o<a&&(n=r(this,o,t,e),!n);o++);return n}shapecast(t){const e=K.getPrimitive(),n=super.shapecast({...t,intersectsPrimitive:t.intersectsTriangle,scratchPrimitive:e,iterate:this.indirect?cs:is});return K.releasePrimitive(e),n}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:r}=n;const o=K.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,p=this.indirect?y=>{const g=this.resolveTriangleIndex(y);N(o,g*3,a,c)}:y=>{N(o,y*3,a,c)},l=K.getPrimitive(),f=t.geometry.index,u=t.geometry.attributes.position,d=t.indirect?y=>{const g=t.resolveTriangleIndex(y);N(l,g*3,f,u)}:y=>{N(l,y*3,f,u)};if(r){if(!(t instanceof Ee))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const y=(g,A,w,h,x,m,b,T)=>{for(let _=w,B=w+h;_<B;_++){d(_),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let M=g,I=g+A;M<I;M++)if(p(M),o.needsUpdate=!0,r(o,l,M,_,x,m,b,T))return!0}return!1};if(s){const g=s;s=function(A,w,h,x,m,b,T,_){return g(A,w,h,x,m,b,T,_)?!0:y(A,w,h,x,m,b,T,_)}}else s=y}return super.bvhcast(t,e,{intersectsRanges:s})}intersectsBox(t,e){return de.set(t.min,t.max,e),de.needsUpdate=!0,this.shapecast({intersectsBounds:n=>de.intersectsBox(n),intersectsTriangle:n=>de.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},r=0,o=1/0){return(this.indirect?Ss:gs)(this,t,e,n,s,r,o)}closestPointToPoint(t,e={},n=0,s=1/0){return Ji(this,t,e,n,s)}}const yi=1e-6,Ms=yi*.5,gi=Math.pow(10,-Math.log10(yi)),Es=Ms*gi;function st(i){return~~(i*gi+Es)}function Ps(i){return`${st(i.x)},${st(i.y)}`}function Hn(i){return`${st(i.x)},${st(i.y)},${st(i.z)}`}function Ds(i){return`${st(i.x)},${st(i.y)},${st(i.z)},${st(i.w)}`}function Cs(i,t,e){e.direction.subVectors(t,i).normalize();const n=i.dot(e.direction);return e.origin.copy(i).addScaledVector(e.direction,-n),e}function mi(){return typeof SharedArrayBuffer<"u"}function vs(i){if(i.buffer instanceof SharedArrayBuffer)return i;const t=i.constructor,e=i.buffer,n=new SharedArrayBuffer(e.byteLength),s=new Uint8Array(e);return new Uint8Array(n).set(s,0),new t(n)}function zs(i){return i.index?i.index.count:i.attributes.position.count}function Bn(i){return zs(i)/3}const Rs=1e-8,Ns=new C;function Ls(i){return~~(i/3)}function Us(i){return i%3}function Xn(i,t){return i.start-t.start}function Gn(i,t){return Ns.subVectors(t,i.origin).dot(i.direction)}function Fs(i,t,e,n=Rs){i.sort(Xn),t.sort(Xn);for(let a=0;a<i.length;a++){const c=i[a];for(let p=0;p<t.length;p++){const l=t[p];if(!(l.start>c.end)){if(c.end<l.start||l.end<c.start)continue;if(c.start<=l.start&&c.end>=l.end)r(l.end,c.end)||i.splice(a+1,0,{start:l.end,end:c.end,index:c.index}),c.end=l.start,l.start=0,l.end=0;else if(c.start>=l.start&&c.end<=l.end)r(c.end,l.end)||t.splice(p+1,0,{start:c.end,end:l.end,index:l.index}),l.end=c.start,c.start=0,c.end=0;else if(c.start<=l.start&&c.end<=l.end){const f=c.end;c.end=l.start,l.start=f}else if(c.start>=l.start&&c.end>=l.end){const f=l.end;l.end=c.start,c.start=f}else throw new Error}if(e.has(c.index)||e.set(c.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(c.index).push(l.index),e.get(l.index).push(c.index),o(l)&&(t.splice(p,1),p--),o(c)){i.splice(a,1),a--;break}}}s(i),s(t);function s(a){for(let c=0;c<a.length;c++)o(a[c])&&(a.splice(c,1),c--)}function r(a,c){return Math.abs(c-a)<n}function o(a){return Math.abs(a.end-a.start)<n}}const Wn=1e-5,jn=1e-4;class ks{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let s=1/0,r=null;for(let c=0,p=e.length;c<p;c++){const l=e[c];if(o(l,t)&&o(l,n))continue;const f=a(l,t),u=a(l,n),d=Math.min(f,u);d<s&&(s=d,r=l)}return r;function o(c,p){const l=c.origin.distanceTo(p.origin)>Wn;return c.direction.angleTo(p.direction)>jn||l}function a(c,p){const l=c.origin.distanceTo(p.origin),f=c.direction.angleTo(p.direction);return l/Wn+f/jn}}}const We=new C,je=new C,he=new mn;function Vs(i,t,e){const n=i.attributes,s=i.index,r=n.position,o=new Map,a=new Map,c=Array.from(t),p=new ks;for(let l=0,f=c.length;l<f;l++){const u=c[l],d=Ls(u),y=Us(u);let g=3*d+y,A=3*d+(y+1)%3;s&&(g=s.getX(g),A=s.getX(A)),We.fromBufferAttribute(r,g),je.fromBufferAttribute(r,A),Cs(We,je,he);let w,h=p.findClosestRay(he);h===null&&(h=he.clone(),p.addRay(h)),a.has(h)||a.set(h,{forward:[],reverse:[],ray:h}),w=a.get(h);let x=Gn(h,We),m=Gn(h,je);x>m&&([x,m]=[m,x]),he.direction.dot(h.direction)<0?w.reverse.push({start:x,end:m,index:u}):w.forward.push({start:x,end:m,index:u})}return a.forEach(({forward:l,reverse:f},u)=>{Fs(l,f,o,e),l.length===0&&f.length===0&&a.delete(u)}),{disjointConnectivityMap:o,fragmentMap:a}}const $s=new kt,qe=new C,Os=new Jt,Ye=["","",""];class Hs{constructor(){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(r=>~~(r/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(r=>r%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:s,degenerateEpsilon:r}=this,o=e?x:h,a=new Map,{attributes:c}=t,p=e?Object.keys(c):null,l=t.index,f=c.position;let u=Bn(t);const d=u;let y=0;n&&(y=t.drawRange.start,t.drawRange.count!==1/0&&(u=~~(t.drawRange.count/3)));let g=this.data;(!g||g.length<3*d)&&(g=new Int32Array(3*d)),g.fill(-1);let A=0,w=new Set;for(let m=y,b=u*3+y;m<b;m+=3){const T=m;for(let _=0;_<3;_++){let B=T+_;l&&(B=l.getX(B)),Ye[_]=o(B)}for(let _=0;_<3;_++){const B=(_+1)%3,M=Ye[_],I=Ye[B],P=`${I}_${M}`;if(a.has(P)){const S=T+_,E=a.get(P);g[S]=E,g[E]=S,a.delete(P),A+=2,w.delete(E)}else{const S=`${M}_${I}`,E=T+_;a.set(S,E),w.add(E)}}}if(s){const{fragmentMap:m,disjointConnectivityMap:b}=Vs(t,w,r);w.clear(),m.forEach(({forward:T,reverse:_})=>{T.forEach(({index:B})=>w.add(B)),_.forEach(({index:B})=>w.add(B))}),this.unmatchedDisjointEdges=m,this.disjointConnections=b,A=u*3-w.size}this.matchedEdges=A,this.unmatchedEdges=w.size,this.data=g;function h(m){return qe.fromBufferAttribute(f,m),Hn(qe)}function x(m){let b="";for(let T=0,_=p.length;T<_;T++){const B=c[p[T]];let M;switch(B.itemSize){case 1:M=st(B.getX(m));break;case 2:M=Ps($s.fromBufferAttribute(B,m));break;case 3:M=Hn(qe.fromBufferAttribute(B,m));break;case 4:M=Ds(Os.fromBufferAttribute(B,m));break}b!==""&&(b+="|"),b+=M}return b}}}class qn extends Ti{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new Z,this._previousMatrix.elements.fill(0),this._halfEdges=null,this._boundsTree=null,this._groupIndices=null,this._hash=null}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,s=e.elements;for(let r=0;r<16;r++)if(n[r]!==s[r])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=mi(),s=t.index,r=t.attributes.position,o=s?`${s.uuid}_${s.count}_${s.version}`:"-1_-1_-1",a=`${r.uuid}_${r.count}_${r.version}`,c=`${t.uuid}_${o}_${a}`;if(this._hash===c)return;if(this._hash=c,n)for(const u in e){const d=e[u];if(d.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");d.array=vs(d.array)}t.boundsTree=new Ee(t,{maxLeafSize:3,indirect:!0,useSharedArrayBuffer:n}),t.halfEdges||(t.halfEdges=new Hs),t.halfEdges.updateFrom(t);const p=Bn(t);(!t.groupIndices||t.groupIndices.length!==p)&&(t.groupIndices=new Uint16Array(p));const l=t.groupIndices,f=t.groups;for(let u=0,d=f.length;u<d;u++){const{start:y,count:g}=f[u];for(let A=y/3,w=(y+g)/3;A<w;A++)l[A]=u}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}class Yn{constructor(){this.coplanarSet=new Map,this.intersectionSet=new Map,this.edgeSet=new Map,this.ids=[]}add(t,e,n=!1){const{intersectionSet:s,coplanarSet:r,ids:o}=this;s.has(t)||(s.set(t,[]),o.push(t)),s.get(t).push(e),n&&(r.has(t)||r.set(t,new Set),r.get(t).add(e))}addIntersectionEdge(t,e){const{edgeSet:n}=this;n.has(t)||n.set(t,new Set),n.get(t).add(e)}getIntersectionEdges(t){return this.edgeSet.get(t)||null}}const Xs=0,Gs=1,Ws=2,js=3,qs=4,xi=5,Ai=6,Ze=1e-10,Ys=1e-15,Zs=1e-10,Ks=1e-10,Zn=new gt,Lt=new gt,Kn=new C,Jn=new C,Qn=new C,Ke=new Si,Ft=new C,Pe=new C;function Js(i,t){i.getNormal(Ft),t.getNormal(Pe);const e=Ft.dot(Pe);if(Math.abs(1-Math.abs(e))>=Zs)return!1;const n=Ft.dot(i.a),s=Ft.dot(t.a);return Math.abs(n-s)<Ks}function ti(i,t,e,n){let s=0,r=1;i.delta(Kn);const o=[t.a,t.b,t.c];for(let a=0;a<3;a++){const c=o[a],p=o[(a+1)%3];Jn.subVectors(p,c),Qn.crossVectors(e,Jn),Ke.setFromNormalAndCoplanarPoint(Qn,c);const l=Ke.distanceToPoint(i.start),f=Ke.normal.dot(Kn);if(Math.abs(f)<Ys){if(l<-Ze)return null;continue}const u=-l/f;if(f>0?s=Math.max(s,u):r=Math.min(r,u),s>r+Ze)return null}return r-s<Ze?null:(i.at(s,n.start),i.at(r,n.end),n)}function ei(i,t,e){let n=0;i.getNormal(Ft),t.getNormal(Pe);const s=[t.a,t.b,t.c];for(let o=0;o<3;o++){Lt.start.copy(s[o]),Lt.end.copy(s[(o+1)%3]);const a=ti(Lt,i,Ft,Zn);a!==null&&(n>=e.length&&e.push(new gt),e[n].copy(a),n++)}const r=[i.a,i.b,i.c];for(let o=0;o<3;o++){Lt.start.copy(r[o]),Lt.end.copy(r[(o+1)%3]);const a=ti(Lt,t,Pe,Zn);a!==null&&(n>=e.length&&e.push(new gt),e[n].copy(a),n++)}return n}const O=new mn,ni=new Z,ye=new gt,ge=new C,Je=[],me=new Mi(()=>new gt),Qe=1e-8,Qs=1e-15,_t=-1,It=1,_e=-2,Ie=2,Zt=0,bt=1,_n=2;let Te=null;function ii(i){Te=i}function wi(i,t,e=null){i.getMidpoint(O.origin),i.getNormal(O.direction),e&&(O.origin.applyMatrix4(e),O.direction.transformDirection(e));const n=t.raycastFirst(O,gn);return!!(n&&O.direction.dot(n.face.normal)>0)?_t:It}function tr(i,t,e=null){function n(){return Math.random()-.5}i.getNormal(ge),O.direction.copy(ge),i.getMidpoint(O.origin),e&&(O.origin.applyMatrix4(e),O.direction.transformDirection(e),ge.transformDirection(e));const s=3;let r=0,o=1/0;for(let a=0;a<s;a++){O.direction.x+=n()*Qe,O.direction.y+=n()*Qe,O.direction.z+=n()*Qe,O.direction.multiplyScalar(-1);const c=t.raycastFirst(O,gn);if(!!(c&&O.direction.dot(c.face.normal)>0)&&r++,c!==null&&(o=Math.min(o,c.distance)),o<=Qs)return c.face.normal.dot(ge)>0?Ie:_e;if(r/s>.5||(a-r+1)/s>.5)break}return r/s>.5?_t:It}function er(i,t){const e=new Yn,n=new Yn;return me.clear(),ni.copy(i.matrixWorld).invert().multiply(t.matrixWorld),i.geometry.boundsTree.bvhcast(t.geometry.boundsTree,ni,{intersectsTriangles(s,r,o,a){if(!rn(s)&&!rn(r)){let c=Js(s,r)?ei(s,r,Je):0;if(c>0||s.intersectsTriangle(r,ye,!0)){const l=i.geometry.boundsTree.resolveTriangleIndex(o),f=t.geometry.boundsTree.resolveTriangleIndex(a);if(e.add(l,f,c),n.add(f,l,c),c>0){const u=ei(s,r,Je);for(let d=0;d<u;d++){const y=me.getInstance().copy(Je[d]);e.addIntersectionEdge(l,y),n.addIntersectionEdge(f,y)}}else{const u=me.getInstance().copy(ye),d=me.getInstance().copy(ye);e.addIntersectionEdge(l,u),n.addIntersectionEdge(f,d)}Te&&(Te.addEdge(ye),Te.addIntersectingTriangles(o,s,a,r))}}return!1}}),{aIntersections:e,bIntersections:n}}function bi(i,t,e=!1){switch(i){case Xs:if(t===It||t===Ie&&!e)return bt;break;case Gs:if(e){if(t===_t)return Zt}else if(t===It||t===_e)return bt;break;case Ws:if(e){if(t===It||t===_e)return bt}else if(t===_t)return Zt;break;case qs:if(t===_t)return Zt;if(t===It)return bt;break;case js:if(t===_t||t===Ie&&!e)return bt;break;case xi:if(!e&&(t===It||t===_e))return bt;break;case Ai:if(!e&&(t===_t||t===Ie))return bt;break;default:throw new Error(`Unrecognized CSG operation enum "${i}".`)}return _n}class nr{constructor(t){this.triangle=new et().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new et().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class si{constructor(){this.data={}}addTriangleIntersection(t,e,n,s){const{data:r}=this;r[t]||(r[t]=new nr(e)),r[t].addTriangle(n,s)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const s in e)n.push(e[s].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,s=new Set,r=[],o=a=>{if(n[a])if(e!==null)n[a].intersects[e]&&r.push(n[a].intersects[e]);else{const c=n[a].intersects;for(const p in c)s.has(p)||(s.add(p),r.push(c[p]))}};if(t!==null)o(t);else for(const a in n)o(a);return r}reset(){this.data={}}}class ir{constructor(){this.enabled=!1,this.triangleIntersectsA=new si,this.triangleIntersectsB=new si,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,s){const{triangleIntersectsA:r,triangleIntersectsB:o}=this;r.addTriangleIntersection(t,e,n,s),o.addTriangleIntersection(n,s,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),ii(this))}complete(){this.enabled&&ii(null)}}const Y=new Z,xe=new Z,q=new Z,ht=new Ei,nt=new et,Bt=new et,Q=new et,dt=new et,Tt=[],it=[],Ae=new Set;function sr(i,t,e,n,s,r={}){const{useGroups:o=!0}=r,{aIntersections:a,bIntersections:c}=er(i,t),p=[];let l=null,f;return f=o?0:-1,oi(i,t,a,e,!1,s,f),ri(i,t,a,e,!1,n,s,f),e.findIndex(d=>d!==Ai&&d!==xi)!==-1&&(s.forEach(d=>d.clearIndexMap()),f=o?i.geometry.groups.length||1:-1,oi(t,i,c,e,!0,s,f),ri(t,i,c,e,!0,n,s,f)),s.forEach(d=>d.clearIndexMap()),Tt.length=0,{groups:p,materials:l}}function ri(i,t,e,n,s,r,o,a=0){Y.copy(t.matrixWorld).invert().multiply(i.matrixWorld),xe.copy(Y).invert(),s?q.copy(Y):q.identity();const c=q.determinant()<0;ht.getNormalMatrix(q).multiplyScalar(c?-1:1);const p=i.geometry.groupIndices,l=i.geometry.index,f=i.geometry.attributes.position,u=t.geometry.boundsTree,d=t.geometry.index,y=t.geometry.attributes.position,g=e.ids;for(let A=0,w=g.length;A<w;A++){const h=g[A],x=a===-1?0:p[h]+a,m=3*h;let b=m+0,T=m+1,_=m+2;l&&(b=l.getX(b),T=l.getX(T),_=l.getX(_)),nt.a.fromBufferAttribute(f,b),nt.b.fromBufferAttribute(f,T),nt.c.fromBufferAttribute(f,_),s&&(nt.a.applyMatrix4(Y),nt.b.applyMatrix4(Y),nt.c.applyMatrix4(Y)),r.reset(),r.initialize(nt,b,T,_);const B=e.coplanarSet.get(h),M=B&&B.size>0;if(r.addConstraintEdge){const E=e.getIntersectionEdges(h);if(E)for(const D of E)r.addConstraintEdge(D);r.triangulate()}else{const D=e.intersectionSet.get(h);for(let v=0,L=D.length;v<L;v++){const $t=D[v],$=B&&B.has($t),J=3*$t;let ot=J+0,at=J+1,St=J+2;d&&(ot=d.getX(ot),at=d.getX(at),St=d.getX(St)),Bt.a.fromBufferAttribute(y,ot),Bt.b.fromBufferAttribute(y,at),Bt.c.fromBufferAttribute(y,St),s||(Bt.a.applyMatrix4(xe),Bt.b.applyMatrix4(xe),Bt.c.applyMatrix4(xe)),r.splitByTriangle(Bt,$)}}const{triangles:I,triangleIndices:P=[],triangleConnectivity:S=[]}=r;for(let E=0,D=o.length;E<D;E++)o[E].initInterpolatedAttributeData(i.geometry,q,ht,b,T,_);Ae.clear();for(let E=0,D=I.length;E<D;E++){if(Ae.has(E))continue;const v=I[E],L=s?null:Y,$t=M?tr(v,u,L):wi(v,u,L);Tt.length=0,it.length=0;for(let $=0,J=n.length;$<J;$++){const ot=bi(n[$],$t,s);ot!==_n&&(Tt.push(ot),it.push(o[$]))}if(it.length!==0){const $=[E];for(;$.length>0;){const J=$.pop();if(Ae.has(J))continue;Ae.add(J);const ot=S[J]||[];for(let lt=0,Ne=ot.length;lt<Ne;lt++){const ut=ot[lt];I[ut]!==null&&$.push(ut)}const at=P[J];let St=null,ve=null,ze=null;at&&(St=at[0],ve=at[1],ze=at[2]);const Re=I[J];nt.getBarycoord(Re.a,dt.a),nt.getBarycoord(Re.b,dt.b),nt.getBarycoord(Re.c,dt.c);for(let lt=0,Ne=it.length;lt<Ne;lt++){const ut=it[lt],Bi=Tt[lt]===Zt,Mt=c!==Bi;ut.appendInterpolatedAttributeData(x,dt.a,St,Mt),Mt?(ut.appendInterpolatedAttributeData(x,dt.c,ze,Mt),ut.appendInterpolatedAttributeData(x,dt.b,ve,Mt)):(ut.appendInterpolatedAttributeData(x,dt.b,ve,Mt),ut.appendInterpolatedAttributeData(x,dt.c,ze,Mt))}}}}}return g.length}function oi(i,t,e,n,s,r,o=0){Y.copy(t.matrixWorld).invert().multiply(i.matrixWorld),s?q.copy(Y):q.identity();const a=q.determinant()<0;ht.getNormalMatrix(q).multiplyScalar(a?-1:1);const c=t.geometry.boundsTree,p=i.geometry.groupIndices,l=i.geometry.index,u=i.geometry.attributes.position,d=[],y=i.geometry.halfEdges,g=new Set(e.ids),A=Bn(i.geometry);for(let w=0;w<A&&g.size!==A;w++){if(g.has(w))continue;g.add(w),d.push(w);const h=3*w;let x=h+0,m=h+1,b=h+2;l&&(x=l.getX(x),m=l.getX(m),b=l.getX(b)),Q.a.fromBufferAttribute(u,x),Q.b.fromBufferAttribute(u,m),Q.c.fromBufferAttribute(u,b),s&&(Q.a.applyMatrix4(Y),Q.b.applyMatrix4(Y),Q.c.applyMatrix4(Y));const T=wi(Q,c,s?null:Y);Tt.length=0,it.length=0;for(let _=0,B=n.length;_<B;_++){const M=bi(n[_],T,s);M!==_n&&(Tt.push(M),it.push(r[_]))}for(;d.length>0;){const _=d.pop();for(let B=0;B<3;B++){const M=y.getSiblingTriangleIndex(_,B);M!==-1&&!g.has(M)&&(d.push(M),g.add(M))}if(it.length!==0){const B=3*_;let M=B+0,I=B+1,P=B+2;l&&(M=l.getX(M),I=l.getX(I),P=l.getX(P));const S=o===-1?0:p[_]+o;if(Q.a.fromBufferAttribute(u,M),Q.b.fromBufferAttribute(u,I),Q.c.fromBufferAttribute(u,P),!rn(Q))for(let E=0,D=it.length;E<D;E++){const v=it[E],$=Tt[E]===Zt!==a;v.appendIndexFromGeometry(i.geometry,q,ht,S,M,$),$?(v.appendIndexFromGeometry(i.geometry,q,ht,S,P,$),v.appendIndexFromGeometry(i.geometry,q,ht,S,I,$)):(v.appendIndexFromGeometry(i.geometry,q,ht,S,I,$),v.appendIndexFromGeometry(i.geometry,q,ht,S,P,$))}}}}}function rr(i){return i=~~i,i+4-i%4}class or{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(t===this.type)return;if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=mi()?SharedArrayBuffer:ArrayBuffer,s=new e(new n(rr(t*e.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let s=0,r=t.length;s<r;s++)e[n+s]=t[s];this.length+=t.length}clear(){this.length=0}}const j=new C,tn=new C,en=new C,nn=new C,we=new Jt,cr=new Jt,ar=new Jt,lr=new Jt;function ur(i,t,e,n,s,r=!1,o=!1){return s.set(0,0,0,0).addScaledVector(i,n.x).addScaledVector(t,n.y).addScaledVector(e,n.z),r&&s.normalize(),o&&s.multiplyScalar(-1),s}function ci(i,t,e){switch(t){case 1:e.push(i.x);break;case 2:e.push(i.x,i.y);break;case 3:e.push(i.x,i.y,i.z);break;case 4:e.push(i.x,i.y,i.z,i.w);break}}class sn extends or{get count(){return this.length/this.itemSize}constructor(...t){super(...t),this.itemSize=1,this.normalized=!1}}class fr{constructor(){this.attributeData={},this.groupIndices=[],this.forwardIndexMap=new Map,this.invertedIndexMap=new Map,this.interpolatedFields={}}initFromGeometry(t,e){this.clear();const{attributeData:n}=this,s=t.attributes;for(let r=0,o=e.length;r<o;r++){const a=e[r],c=s[a],p=c.array.constructor;n[a]||(n[a]=new sn(p)),n[a].setType(p),n[a].itemSize=c.itemSize,n[a].normalized=c.normalized}for(const r in n.attributes)e.includes(r)||n.delete(r)}initInterpolatedAttributeData(t,e,n,s,r,o){const{attributeData:a,interpolatedFields:c}=this,{attributes:p}=t;for(const l in a){const f=p[l];if(!f)throw new Error(`CSG Operations: Attribute ${l} not available on geometry.`);let u,d,y;if(l==="position"?(u=tn.fromBufferAttribute(f,s).applyMatrix4(e),d=en.fromBufferAttribute(f,r).applyMatrix4(e),y=nn.fromBufferAttribute(f,o).applyMatrix4(e)):l==="normal"?(u=tn.fromBufferAttribute(f,s).applyNormalMatrix(n),d=en.fromBufferAttribute(f,r).applyNormalMatrix(n),y=nn.fromBufferAttribute(f,o).applyNormalMatrix(n)):l==="tangent"?(u=tn.fromBufferAttribute(f,s).transformDirection(e),d=en.fromBufferAttribute(f,r).transformDirection(e),y=nn.fromBufferAttribute(f,o).transformDirection(e)):(u=cr.fromBufferAttribute(f,s),d=ar.fromBufferAttribute(f,r),y=lr.fromBufferAttribute(f,o)),!c[l])c[l]=[u.clone(),d.clone(),y.clone()];else{const g=c[l];g[0].copy(u),g[1].copy(d),g[2].copy(y)}}}appendInterpolatedAttributeData(t,e,n=null,s=!1){const{groupIndices:r,attributeData:o,interpolatedFields:a,forwardIndexMap:c,invertedIndexMap:p}=this;for(;r.length<=t;)r.push(new sn(Uint32Array));const l=s?p:c,f=r[t];if(n!==null&&l.has(n))f.push(l.get(n));else{l.set(n,o.position.count),f.push(o.position.count);for(const u in a){const d=o[u],y=u==="normal"||u==="tangent",g=s&&y,A=d.itemSize,[w,h,x]=a[u];ur(w,h,x,e,we,y,g),ci(we,A,d)}}}appendIndexFromGeometry(t,e,n,s,r,o=!1){const{groupIndices:a,attributeData:c,forwardIndexMap:p,invertedIndexMap:l}=this;for(;a.length<=s;)a.push(new sn(Uint32Array));const f=o?l:p,u=a[s];if(r!==null&&f.has(r))u.push(f.get(r));else{f.set(r,c.position.count),u.push(c.position.count);const{attributes:d}=t;for(const y in c){const g=c[y],A=d[y];if(!A)throw new Error(`CSG Operations: Attribute ${y} not available on geometry.`);const w=A.itemSize;y==="position"?(j.fromBufferAttribute(A,r).applyMatrix4(e),g.push(j.x,j.y,j.z)):y==="normal"?(j.fromBufferAttribute(A,r).applyNormalMatrix(n),o&&j.multiplyScalar(-1),g.push(j.x,j.y,j.z)):y==="tangent"?(j.fromBufferAttribute(A,r).transformDirection(e),o&&j.multiplyScalar(-1),g.push(j.x,j.y,j.z)):(we.fromBufferAttribute(A,r),ci(we,w,g))}}}buildGeometry(t,e){let n=!1;const{groupIndices:s,attributeData:r}=this,{attributes:o,index:a}=t;for(const l in r){const f=r[l],{type:u,itemSize:d,normalized:y,length:g,count:A}=f,w=f.array.buffer;let h=o[l];(!h||h.count<A||h.array.type!==u)&&(h=new Se(new u(g),d,y),t.setAttribute(l,h),n=!0),h.array.set(new u(w,0,g),0),h.needsUpdate=!0}const c=s.reduce((l,f)=>f.count+l,0);(!t.index||a.count<c||a.array.type!==Uint32Array)&&(t.setIndex(new Se(new Uint32Array(c),1)),n=!0),t.clearGroups();let p=0;for(let l=0,f=Math.min(e.length,s.length);l<f;l++){const{index:u,materialIndex:d}=e[l],{count:y}=s[u],g=s[u].array.buffer;y!==0&&(t.index.array.set(new Uint32Array(g,0,y),p),t.addGroup(p,y,d),p+=y)}t.setDrawRange(0,p),t.boundsTree=null,n&&t.dispose()}clearIndexMap(){this.forwardIndexMap.clear(),this.invertedIndexMap.clear()}clear(){const{groupIndices:t,attributeData:e}=this;this.interpolatedFields={};for(const n in e)e[n].clear();t.forEach(n=>{n.clear()}),this.clearIndexMap()}}function dr(i,t){for(const e in i.attributes)t.includes(e)||(i.deleteAttribute(e),i.dispose());return i}function pr(i,t){const e=[];for(let n=0,s=i.length;n<s;n++){const r=i[n],o=t[r.materialIndex];e.push({...r,materialIndex:t.indexOf(o)})}return e}function hr(i,t){const e=[],n=new Map;for(let s=0,r=i.length;s<r;s++){const o=i[s];n.has(o.materialIndex)||(n.set(o.materialIndex,e.length),e.push(t[o.materialIndex])),o.materialIndex=n.get(o.materialIndex)}return e}function yr(i){for(let t=0;t<i.length-1;t++){const e=i[t],n=i[t+1];if(e.materialIndex===n.materialIndex){const s=e.start,r=n.start+n.count;n.start=s,n.count=r-s,i.splice(t,1),t--}}}function ai(i,t){let e=t;return Array.isArray(t)||(e=[],i.forEach(n=>{e[n.materialIndex]=t})),e}class xr{constructor(){this.triangleSplitter=new Pi,this.geometryBuilders=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.removeUnusedMaterials=!0,this.debug=new ir}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(n=>({...n}))}evaluate(t,e,n,s=new qn){let r=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s],r=!1),s.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:o,geometryBuilders:a,attributes:c,useGroups:p,consolidateGroups:l,removeUnusedMaterials:f,debug:u}=this;for(;a.length<s.length;)a.push(new fr);s.forEach((x,m)=>{a[m].initFromGeometry(t.geometry,c),dr(x.geometry,c)}),u.init(),sr(t,e,n,o,a,{useGroups:p}),u.complete();const d=this.getGroupRanges(t.geometry),y=ai(d,t.material),g=this.getGroupRanges(e.geometry),A=ai(g,e.material);g.forEach(x=>x.materialIndex+=y.length);const w=[...y,...A];let h=[...d,...g].map((x,m)=>({...x,index:m}));return p?p&&l&&(h=pr(h,w),h.sort((x,m)=>x.materialIndex-m.materialIndex)):h=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach((x,m)=>{const b=x.geometry;a[m].buildGeometry(b,h),t.matrixWorld.decompose(x.position,x.quaternion,x.scale),x.updateMatrix(),x.matrixWorld.copy(t.matrixWorld),p?(x.material=w,l&&yr(b.groups),f&&(x.material=hr(b.groups,w))):x.material=w[0]}),r?s:s[0]}evaluateHierarchy(t,e=new qn){t.updateMatrixWorld(!0);const n=(r,o)=>{const a=r.children;for(let c=0,p=a.length;c<p;c++){const l=a[c];l.isOperationGroup?n(l,o):o(l)}},s=r=>{const o=r.children;let a=!1;for(let p=0,l=o.length;p<l;p++){const f=o[p];a=s(f)||a}const c=r.isDirty();if(c&&r.markUpdated(),a&&!r.isOperationGroup){let p;return n(r,l=>{p?p=this.evaluate(p,l,l.operation):p=this.evaluate(r,l,l.operation)}),r._cachedGeometry=p.geometry,r._cachedMaterials=p.material,!0}else return a||c};return s(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}export{Xs as A,qn as B,qs as D,xr as E,xi as H,js as I,Ee as M,Ws as R,Gs as S,Ai as a,R as b};
