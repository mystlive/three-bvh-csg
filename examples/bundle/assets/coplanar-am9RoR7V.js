import{W as D,S as F,D as G,A as P,P as H,O as Q,G as U,M as I,a as R,F as T,b as A,B as V,c as _,V as s,Q as w,E as B,C as z}from"./LegacyTriangleSplitter-CSged5Ks.js";import{g as j}from"./lil-gui.module.min-BH_YJbPT.js";import{S as N,H as k,a as Y,D as J,I as K,R as X,A as Z,B as i,E as $}from"./Evaluator-BcPkntuF.js";const ee=20;function p(n,e,t){return new z(n/2,n/2,e,ee)}const u={operation:N,overlap:0,rotation:0,wireframe:!1,displayBrushes:!0};let c,h,d,b,v,E=!0,S;const g=[];te();function te(){c=new D({antialias:!0}),c.setPixelRatio(window.devicePixelRatio),c.setSize(window.innerWidth,window.innerHeight),c.setClearColor(1118481,1),document.body.appendChild(c.domElement),d=new F;const e=new G(16777215,3.5);e.position.set(-1,2,3),d.add(e,e.target),d.add(new P(11583173,.35)),h=new H(75,window.innerWidth/window.innerHeight,.1,100),h.position.set(0,5,14),h.updateProjectionMatrix(),v=new Q(h,c.domElement),v.target.set(0,0,0),v.update(),S=new $,S.attributes=["position","normal"],S.useGroups=!0;const t=4,r=ne(),o=(r.length-1)*t;for(let a=0;a<r.length;a++){const l=r[a],q=a*t-o/2,y=new U;y.position.x=q,d.add(y);const C=new I({color:16777215,opacity:.15,transparent:!0,depthWrite:!1,side:R,premultipliedAlpha:!0}),M=new I({color:15277667,opacity:.15,transparent:!0,depthWrite:!1,side:R,premultipliedAlpha:!0,roughness:.25});l.brush1.material=C,l.brush2.material=M,y.add(l.brush1,l.brush2);const m=C.clone();m.side=T,m.opacity=1,m.transparent=!1,m.depthWrite=!0;const f=M.clone();f.side=T,f.opacity=1,f.transparent=!1,f.depthWrite=!0;const x=new Map;x.set(C,m),x.set(M,f);const W=new A(new V,new I);d.add(W);const O=new A(W.geometry,new _({wireframe:!0,color:0,opacity:.15,transparent:!0}));d.add(O),g.push({label:l.label,brush1:l.brush1,brush2:l.brush2,posStart:l.posStart,posEnd:l.posEnd,rotStart:l.rotStart,rotEnd:l.rotEnd,result:W,wireframe:O,materialMap:x})}b=new j,b.add(u,"operation",{ADDITION:Z,SUBTRACTION:N,REVERSE_SUBTRACTION:X,INTERSECTION:K,DIFFERENCE:J,HOLLOW_INTERSECTION:Y,HOLLOW_SUBTRACTION:k}).onChange(()=>{E=!0}),b.add(u,"overlap",0,1,.01).onChange(()=>{E=!0}),b.add(u,"rotation",0,1,.01).onChange(()=>{E=!0}),b.add(u,"wireframe"),b.add(u,"displayBrushes"),window.addEventListener("resize",function(){h.aspect=window.innerWidth/window.innerHeight,h.updateProjectionMatrix(),c.setSize(window.innerWidth,window.innerHeight)},!1),L()}function ne(){const n=[];{const e=new s(0,2,0),t=new w,r=new i(p(2,2)),o=new i(p(2,2));o.position.copy(e),n.push({label:"axis-aligned",brush1:r,brush2:o,posStart:e,posEnd:new s(0,0,0),rotStart:t,rotEnd:t.clone()})}{const e=new w().setFromEuler(new B(.7,.4,.3)),t=new s(0,2,0).applyQuaternion(e),r=e.clone(),o=new i(p(2,2)),a=new i(p(2,2));o.quaternion.copy(e),a.quaternion.copy(e),a.position.copy(t),n.push({label:"rotated",brush1:o,brush2:a,posStart:t,posEnd:new s(0,0,0),rotStart:r,rotEnd:r.clone()})}{const e=new s(0,1.5,0),t=new w,r=new i(p(2,2)),o=new i(p(1,1));o.position.copy(e),n.push({label:"partial overlap",brush1:r,brush2:o,posStart:e,posEnd:new s(0,0,0),rotStart:t,rotEnd:t.clone()})}{const e=new s(0,2.0000001,0),t=new w,r=new i(p(2,2)),o=new i(p(2,2));o.position.copy(e),n.push({label:"epsilon offset",brush1:r,brush2:o,posStart:e,posEnd:new s(0,1e-7,0),rotStart:t,rotEnd:t.clone()})}{const e=new s(0,2,0),t=new w().setFromEuler(new B(0,Math.PI/4,0)),r=new w().setFromAxisAngle(new s(0,1,0),3*Math.PI/4),o=new i(p(2,2)),a=new i(p(2,2));a.quaternion.copy(t),a.position.copy(e),n.push({label:"rotated 45",brush1:o,brush2:a,posStart:e,posEnd:new s(1,2,1),rotStart:t,rotEnd:r})}{const e=new s(0,1.75,0),t=new w,r=new i(p(3,3)),o=new i(p(.5,.5));o.position.copy(e),n.push({label:"scale mismatch",brush1:r,brush2:o,posStart:e,posEnd:new s(0,0,0),rotStart:t,rotEnd:t.clone()})}return n}function L(){if(requestAnimationFrame(L),E){E=!1,d.updateMatrixWorld(!0);for(let n=0;n<g.length;n++){const e=g[n];window.performance.now(),e.brush2.position.lerpVectors(e.posStart,e.posEnd,u.overlap),e.brush2.quaternion.slerpQuaternions(e.rotStart,e.rotEnd,u.rotation),e.brush1.updateMatrixWorld(!0),e.brush2.updateMatrixWorld(!0),S.evaluate(e.brush1,e.brush2,u.operation,e.result),e.result.material=e.result.material.map(t=>e.materialMap.get(t))}}for(const n of g)n.brush1.visible=u.displayBrushes,n.brush2.visible=u.displayBrushes,n.wireframe.visible=u.wireframe;c.render(d,h)}
